# 5. Асинхронный сброс
Неправильная реализация асинхронного сброса в цифровой логической схеме может привести к серьёзным сбоям в работе.  

Многим инженерам нравится идея возможности применить сброс к своей схеме и перевести логику в известное состояние. Cамая большая проблема с асинхронным сбросом — это сброс сброса, также называемый снятием сброса. Эта тема будет подробно рассмотрена в разделе 6.0.  

Триггеры с асинхронным сбросом имеют вывод сброса в своей конструкции. Вывод сброса обычно имеет активный низкий уровень (триггер переходит в состояние сброса, когда сигнал, подключённый к выводу сброса триггера,переходит на логический низкий уровень).


## 5.1 Стиль кода и примеры
Код Verilog из примера 5a и код VHDL из примера 5b демонстрируют правильный способ описания асинхронных триггеров со сбросом. Обратите внимание, что сброс является частью списка чувствительности. В Verilog добавление сброса в список чувствительности делает сброс асинхронным. Для корректной симуляции асинхронного триггера в Verilog список чувствительности должен быть активен только по активному фронту сигнала асинхронного сброса. Следовательно, в примере 5a процедурный блок always будет запущен по активному фронту сигнала сброса, а затем условие if будет проверять корректность уровня сброса.  

```Verilog
module async_resetFFstyle (
  output reg q,
  input  d, clk, rst_n);
  // Verilog-2001: permits comma-separation
  // @(posedge clk, negedge rst_n)
  always @(posedge clk or negedge rst_n)
    if (!rst_n) q <= 1'b0;
    else        q <= d;
endmodule
```
<p align=center> Пример 5a — Корректный способ описания триггера с асинхронным сбросом с использованием Verilog-2001 </br></br></p>

```VHDL
library ieee;
use ieee.std_logic_1164.all;
entity asyncresetFFstyle is
  port (
    clk   : in  std_logic;
    rst_n : in  std_logic;
    d     : in  std_logic;
    q     : out std_logic);
end asyncresetFFstyle;

architecture rtl of asyncresetFFstyle is
begin
  process (clk, rst_n)
  begin
    if (rst_n = '0') then
      q <= '0';
    elsif (clk'event and clk = '1') then
      q <= d;
    end if;
  end process;
end rtl;
```
<p align=center> Пример 5b — Корректный способ описания триггера с асинхронным сбросом с использованием VHDL </br></br></p>

Synopsys требует, что если какой-либо сигнал в списке чувствительности чувствителен к фронту, то все сигналы в списке чувствительности также должны быть чувствительны к фронту. Другими словами, Synopsys диктует правильный стиль кодирования. Моделирование на Verilog не предъявляет такого требования, но если бы список чувствительности был чувствителен к чему-либо большему, чем только активный фронт тактового сигнала и сигнала сброса, модель моделирования была бы неверной[5]. Кроме того, в список чувствительности могут быть включены только сигналы тактового сигнала и сигнала сброса. Если включены другие сигналы (разрешено в Verilog, но неправильный стиль кодирования Verilog RTL синтеза), модель моделирования будет некорректной для триггера, и Synopsys сообщит об ошибке при чтении модели для синтеза.

Для VHDL включение сброса в список чувствительности и проверка сброса перед оператором «if clk’event and clk = 1» делает сброс асинхронным. Также обратите внимание, что сброс имеет приоритет перед любым другим назначением (включая тактовый сигнал) благодаря использованию стиля кодирования if/else. В силу особенностей списка чувствительности VHDL и стиля кодирования триггеров, дополнительные сигналы могут быть включены в список чувствительности без каких-либо негативных последствий для моделирования и синтеза. Однако хороший стиль кодирования рекомендует, чтобы в списке чувствительности были только те сигналы, которые могут напрямую изменить выход триггера. Это тактовый сигнал и асинхронный сброс. Все остальные сигналы замедлят моделирование и будут проигнорированы синтезом.


