# 5. Асинхронный сброс
Неправильная реализация асинхронного сброса в цифровой логической схеме может привести к серьёзным сбоям в работе.  

Многим инженерам нравится идея возможности применить сброс к своей схеме и перевести логику в известное состояние. Cамая большая проблема с асинхронным сбросом — это сброс сброса, также называемый снятием сброса. Эта тема будет подробно рассмотрена в разделе 6.0.  

Триггеры с асинхронным сбросом имеют вывод сброса в своей конструкции. Вывод сброса обычно имеет активный низкий уровень (триггер переходит в состояние сброса, когда сигнал, подключённый к выводу сброса триггера,переходит на логический низкий уровень).


## 5.1 Стиль кода и примеры
Код Verilog из примера 5a и код VHDL из примера 5b демонстрируют правильный способ описания асинхронных триггеров со сбросом. Обратите внимание, что сброс является частью списка чувствительности. В Verilog добавление сброса в список чувствительности делает сброс асинхронным. Для корректной симуляции асинхронного триггера в Verilog список чувствительности должен быть активен только по активному фронту сигнала асинхронного сброса. Следовательно, в примере 5a процедурный блок always будет запущен по активному фронту сигнала сброса, а затем условие if будет проверять корректность уровня сброса.  

```Verilog
module async_resetFFstyle (
  output reg q,
  input  d, clk, rst_n);
  // Verilog-2001: permits comma-separation
  // @(posedge clk, negedge rst_n)
  always @(posedge clk or negedge rst_n)
    if (!rst_n) q <= 1'b0;
    else        q <= d;
endmodule
```
<p align=center> Пример 5a — Корректный способ описания триггера с асинхронным сбросом с использованием Verilog-2001 </br></br></p>

```VHDL
library ieee;
use ieee.std_logic_1164.all;
entity asyncresetFFstyle is
  port (
    clk   : in  std_logic;
    rst_n : in  std_logic;
    d     : in  std_logic;
    q     : out std_logic);
end asyncresetFFstyle;

architecture rtl of asyncresetFFstyle is
begin
  process (clk, rst_n)
  begin
    if (rst_n = '0') then
      q <= '0';
    elsif (clk'event and clk = '1') then
      q <= d;
    end if;
  end process;
end rtl;
```
<p align=center> Пример 5b — Корректный способ описания триггера с асинхронным сбросом с использованием VHDL </br></br></p>

Synopsys требует, что если какой-либо сигнал в списке чувствительности чувствителен к фронту, то все сигналы в списке чувствительности также должны быть чувствительны к фронту. Другими словами, Synopsys диктует правильный стиль кодирования. Моделирование на Verilog не предъявляет такого требования, но если бы список чувствительности был чувствителен к чему-либо большему, чем только активный фронт тактового сигнала и сигнала сброса, модель моделирования была бы неверной[5]. Кроме того, в список чувствительности могут быть включены только сигналы тактового сигнала и сигнала сброса. Если включены другие сигналы (разрешено в Verilog, но неправильный стиль кодирования Verilog RTL синтеза), модель моделирования будет некорректной для триггера, и Synopsys сообщит об ошибке при чтении модели для синтеза.

Для VHDL включение сброса в список чувствительности и проверка сброса перед оператором «if clk’event and clk = 1» делает сброс асинхронным. Также обратите внимание, что сброс имеет приоритет перед любым другим назначением (включая тактовый сигнал) благодаря использованию стиля кодирования if/else. В силу особенностей списка чувствительности VHDL и стиля кодирования триггеров, дополнительные сигналы могут быть включены в список чувствительности без каких-либо негативных последствий для моделирования и синтеза. Однако хороший стиль кодирования рекомендует, чтобы в списке чувствительности были только те сигналы, которые могут напрямую изменить выход триггера. Это тактовый сигнал и асинхронный сброс. Все остальные сигналы замедлят моделирование и будут проигнорированы синтезом.

Подход к синтезу асинхронных сбросов будет зависеть от подхода разработчика к дереву буфера сброса. Если сброс управляется непосредственно с внешнего вывода, то обычно выполнение set_drive 0 на выводе сброса и set_dont_touch_network на сети сброса защитит сеть от модификации при синтезе. Однако есть как минимум одна статья ESNUG, указывающая на то, что это не всегда так [18].

Один из участников ESNUG[17] указывает, что иногда может также потребоваться set_resistance 0 в цепи сброса. В качестве альтернативы, вместо set_resistance 0 в цепи, вы можете создать пользовательскую модель нагрузки проводов (Wire Load Model) с сопротивлением = 0 и применить её к входному порту сброса командой: set_wire_load -port_list reset В недавно обновлённой статье SolvNet также отмечается, что, начиная с версии Synopsys 2001.08, определение идеальных цепей немного изменилось[41] и что команда set_ideal_net может использоваться для создания идеальных цепей и «не получать обновления синхронизации, не получать оптимизацию задержки и не получать исправление DRC». Наш коллега Крис Кигл сообщил, что применение команды set_disable_timing в сетях для проектов до версии 2001.08 помогло очистить отчёты временного анализа [2], что, похоже, подтверждается двумя другими статьями SolvNet,одна из которых посвящена синтезу, а другая — физическому синтезу, где рекомендуется использовать как команду set_false_path, так и команду set_disable_timing [35].

## 5.2 Моделирование триггеров с асинхронным сбросом и асинхронной установкой в Verilog
Здесь следует сделать ещё одно замечание относительно моделирования асинхронных сбросов в Verilog. Имитационная модель триггера, включающая как асинхронную установку, так и асинхронный сброс в Verilog, может работать некорректно без небольшой помощи разработчика. Как правило, в большинстве синхронных проектов нет триггеров, содержащих как асинхронную установку, так и асинхронный сброс, но в некоторых случаях такой триггер требуется. Стиль кодирования Примера 6 можно использовать для коррекции моделирования RTL в Verilog, где сброс и установка активируются одновременно, а сброс снимается первым.

Во-первых, отметим, что проблема заключается только в моделировании, а не в синтезе (синтез предполагает правильный триггер с асинхронной установкой/сбросом). Проблема моделирования возникает из-за того, что блок Always активируется только по активному фронту сигналов установки, сброса или тактового сигнала. Если сброс становится активным, а затем активируется и установка, то, если сброс становится неактивным, триггер должен сначала перейти в состояние сброса, а затем в состояние установки. Поскольку оба этих входа асинхронные, установка должна быть активна сразу после снятия сигнала сброса, но в Verilog это не будет работать, поскольку нет способа активировать блок Always до следующего переднего фронта тактового сигнала.

Для тех редких проектов, где разрешено одновременное подтверждение сброса и установки, а затем сброс снимается первым, решение этой проблемы моделирования заключается в моделировании триггера с помощью самокорректирующегося кода, заключённого в директивы translate_off/translate_on, и принудительном выводе корректного значения для этого одного условия. Лучшая рекомендация здесь — избегать, насколько это возможно, условий, требующих триггера, использующего как асинхронную установку, так и асинхронный сброс. Код в примере 6 демонстрирует фикс, который обеспечит корректную симуляцию и гарантирует соответствие между симуляциями до и после синтеза. Этот код использует директивы translate_off/translate_on для принудительного вывода корректного значения для условия исключения [5].

```Verilog
// Good DFF with asynchronous set and reset and self-
// correcting set-reset assignment
module dff3_aras (
  output reg q,
  input  d, clk, rst_n, set_n);
  
  always @(posedge clk or negedge rst_n or negedge set_n)
    if      (!rst_n) q <= 0; // asynchronous reset
    else if (!set_n) q <= 1; // asynchronous set
    else             q <= d;

  // synopsys translate_off
  always @(rst_n or set_n)
    if (rst_n && !set_n) force   q = 1;
    else                 release q;
  // synopsys translate_on
endmodule
```
<p align=center> Пример 6 — Асинхронный SET/RESET в Verilog </br></br></p>

## 5.3 Преимущества асинхронных сбросов
Наибольшее преимущество использования асинхронных сбросов заключается в том, что, пока в библиотеке поставщика есть асинхронно сбрасываемые триггеры, путь данных гарантированно будет чистым. Проекты, работающие на пределе таймингов путей данных, не могут позволить себе добавлять вентили и дополнительные задержки в цепи данных из-за логики, вставленной для обработки синхронных сбросов. Используя асинхронный сброс, разработчик гарантированно не добавит сброс в путь данных. Код в примере 7 предполагает асинхронные сбросы, которые не будут добавлены в путь данных.


```Verilog
module ctr8ar (
  output reg [7:0] q,
  output reg       co,
  input      [7:0] d,
  input            ld, rst_n, clk);
  
  always @(posedge clk or negedge rst_n)
    if      (!rst_n) {co,q} <= 9'b0;     // async reset
    else if (ld)     {co,q} <= d;        // sync load
    else             {co,q} <= q + 1'b1; // sync increment
endmodule
```
<p align=center> Пример 7a — Код Verilog-2001 для загружаемого счетчика с асинхронным сбросом </br></br></p>

```VHDL
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
entity ctr8ar is
  port (
  clk      : in std_logic;
  rst_n    : in std_logic;
  d        : in std_logic;
  ld       : in std_logic;
  q        : out std_logic_vector(7 downto 0);
  co       : out std_logic);
end ctr8ar;

architecture rtl of ctr8ar is
  signal count : std_logic_vector(8 downto 0);
begin
  co <= count(8);
  q <= count(7 downto 0);
  
  process (clk)
  begin
    if (rst_n = '0') then
      count <= (others => '0');       -- sync reset
      elsif (clk'event and clk = '1') then
        if (ld = '1') then
          count <= '0' & d;           -- sync load
        else
          count <= count + 1;         -- sync increment
      end if;
    end if;
  end process;
end rtl;
```
<p align=center> Пример 7b — Код VHDL для загружаемого счетчика с асинхронным сбросом </br></br></p>

